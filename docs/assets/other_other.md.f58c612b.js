import{o as n,c as s,d as a}from"./app.9f9f1749.js";const e='{"title":"其它","description":"","frontmatter":{},"headers":[{"level":2,"title":"systemctl 服务","slug":"systemctl-服务"},{"level":2,"title":"并发编程","slug":"并发编程"},{"level":2,"title":"函数式编程","slug":"函数式编程"},{"level":2,"title":"Rabbit","slug":"rabbit"},{"level":3,"title":"注意:","slug":"注意"},{"level":3,"title":"exchange 交换机","slug":"exchange-交换机"},{"level":3,"title":"message 消息","slug":"message-消息"},{"level":3,"title":"死信队列(特殊的 exchange)","slug":"死信队列-特殊的-exchange"},{"level":3,"title":"消费者","slug":"消费者"},{"level":3,"title":"监听器","slug":"监听器"},{"level":3,"title":"高可用","slug":"高可用"},{"level":3,"title":"插件","slug":"插件"},{"level":2,"title":"Spring 事务","slug":"spring-事务"},{"level":2,"title":"SpringMvc 异步处理","slug":"springmvc-异步处理"},{"level":2,"title":"Dockerfile","slug":"dockerfile"},{"level":2,"title":"Gradle","slug":"gradle"},{"level":2,"title":"jira配置","slug":"jira配置"}],"relativePath":"other/other.md","lastUpdated":1627891509326}',t={},p=a('<h1 id="其它"><a class="header-anchor" href="#其它" aria-hidden="true">#</a> 其它</h1><p>乱七八糟 💣💣💣</p><h2 id="systemctl-服务"><a class="header-anchor" href="#systemctl-服务" aria-hidden="true">#</a> systemctl 服务</h2><blockquote><p>/usr/lib/systemd/下, 开机不登录就能启动的服务最好放在 /usr/lib/systemd/system 系统服务, …/user: 用户服务 需要用户登录才可以启动</p></blockquote><div class="language-bash"><pre><code><span class="token comment"># [Unit]、[Service]和[Install]</span>\n<span class="token punctuation">[</span>Unit<span class="token punctuation">]</span>   <span class="token comment"># 主要是服务说明</span>\n<span class="token assign-left variable">Description</span><span class="token operator">=</span>test   <span class="token comment"># 简单描述服务</span>\n<span class="token assign-left variable">After</span><span class="token operator">=</span>network.target    <span class="token comment"># 描述服务类别，表示本服务需要在network服务启动后在启动</span>\n<span class="token assign-left variable">Before</span><span class="token operator">=</span>xxx.service      <span class="token comment"># 表示需要在某些服务启动之前启动，After和Before字段只涉及启动顺序，不涉及依赖关系</span>\n\n<span class="token punctuation">[</span>Service<span class="token punctuation">]</span>  <span class="token comment"># 核心区域</span>\n<span class="token assign-left variable">Type</span><span class="token operator">=</span>forking     <span class="token comment"># 表示后台运行模式。</span>\n<span class="token assign-left variable">User</span><span class="token operator">=</span>root        <span class="token comment"># 设置服务运行的用户</span>\n<span class="token assign-left variable">Group</span><span class="token operator">=</span>root       <span class="token comment"># 设置服务运行的用户组</span>\n<span class="token assign-left variable">KillMode</span><span class="token operator">=</span>control-group   <span class="token comment"># 定义systemd如何停止服务</span>\n<span class="token assign-left variable">PIDFile</span><span class="token operator">=</span>/usr/local/test/test.pid    <span class="token comment"># 存放PID的绝对路径</span>\n<span class="token assign-left variable">Restart</span><span class="token operator">=</span>no        <span class="token comment"># 定义服务进程退出后，systemd的重启方式，默认是不重启</span>\n<span class="token assign-left variable">ExecStart</span><span class="token operator">=</span>/usr/local/test/bin/startup.sh    <span class="token comment"># 服务启动命令，命令需要绝对路径</span>\n<span class="token assign-left variable">ExecReload</span><span class="token operator">=</span>/xxxxx\n<span class="token assign-left variable">ExecStop</span><span class="token operator">=</span>/xxxxx\n<span class="token assign-left variable">PrivateTmp</span><span class="token operator">=</span>true                               <span class="token comment"># 表示给服务分配独立的临时空间</span>\n\n<span class="token punctuation">[</span>Install<span class="token punctuation">]</span>\n<span class="token assign-left variable">WantedBy</span><span class="token operator">=</span>multi-user.target  <span class="token comment"># 多用户</span>\n\n<span class="token comment">#Type的类型有：</span>\n<span class="token comment">#    simple(默认）：# 以ExecStart字段启动的进程为主进程</span>\n<span class="token comment">#    forking:  # ExecStart字段以fork()方式启动，此时父进程将退出，子进程将成为主进程（后台运行）。一般都设置为forking</span>\n<span class="token comment">#    oneshot:  # 类似于simple，但只执行一次，systemd会等它执行完，才启动其他服务</span>\n<span class="token comment">#    dbus：    # 类似于simple, 但会等待D-Bus信号后启动</span>\n<span class="token comment">#    notify:   # 类似于simple, 启动结束后会发出通知信号，然后systemd再启动其他服务</span>\n<span class="token comment">#    idle：    # 类似于simple，但是要等到其他任务都执行完，才会启动该服务。</span>\n<span class="token comment">#</span>\n<span class="token comment">#EnvironmentFile:</span>\n<span class="token comment">#    指定配置文件，和连词号组合使用，可以避免配置文件不存在的异常。</span>\n<span class="token comment">#</span>\n<span class="token comment">#Environment:</span>\n<span class="token comment">#    后面接多个不同的shell变量。</span>\n<span class="token comment">#    例如：</span>\n<span class="token comment">#    Environment=DATA_DIR=/data/elk</span>\n<span class="token comment">#    Environment=LOG_DIR=/var/log/elasticsearch</span>\n<span class="token comment">#    Environment=PID_DIR=/var/run/elasticsearch</span>\n<span class="token comment">#    EnvironmentFile=-/etc/sysconfig/elasticsearch</span>\n<span class="token comment">#</span>\n<span class="token comment">#连词号（-）：在所有启动设置之前，添加的变量字段，都可以加上连词号</span>\n<span class="token comment">#    表示抑制错误，即发生错误时，不影响其他命令的执行。</span>\n<span class="token comment">#    比如`EnviromentFile=-/etc/sysconfig/xxx` 表示即使文件不存在，也不会抛异常</span>\n<span class="token comment">#</span>\n<span class="token comment">#KillMode的类型：</span>\n<span class="token comment">#    control-group(默认)：# 当前控制组里的所有子进程，都会被杀掉</span>\n<span class="token comment">#    process: # 只杀主进程</span>\n<span class="token comment">#    mixed:   # 主进程将收到SIGTERM信号，子进程收到SIGKILL信号</span>\n<span class="token comment">#    none:    # 没有进程会被杀掉，只是执行服务的stop命令</span>\n<span class="token comment">#Restart的类型：</span>\n<span class="token comment">#    no(默认值)： # 退出后无操作</span>\n<span class="token comment">#    on-success:  # 只有正常退出时（退出状态码为0）,才会重启</span>\n<span class="token comment">#    on-failure:  # 非正常退出时，重启，包括被信号终止和超时等</span>\n<span class="token comment">#    on-abnormal: # 只有被信号终止或超时，才会重启</span>\n<span class="token comment">#    on-abort:    # 只有在收到没有捕捉到的信号终止时，才会重启</span>\n<span class="token comment">#    on-watchdog: # 超时退出时，才会重启</span>\n<span class="token comment">#    always:      # 不管什么退出原因，都会重启</span>\n<span class="token comment">#    # 对于守护进程，推荐用on-failure</span>\n<span class="token comment">#RestartSec字段：</span>\n<span class="token comment">#    表示systemd重启服务之前，需要等待的秒数：RestartSec: 30</span>\n<span class="token comment">#</span>\n<span class="token comment">#各种Exec*字段：</span>\n<span class="token comment">#    # Exec* 后面接的命令，仅接受“指令 参数 参数..”格式，不能接受&lt;&gt;|&amp;等特殊字符，很多bash语法也不支持。如果想支持bash语法，需要设置Tyep=oneshot</span>\n<span class="token comment">#    ExecStart：    # 启动服务时执行的命令</span>\n<span class="token comment">#    ExecReload：   # 重启服务时执行的命令</span>\n<span class="token comment">#    ExecStop：     # 停止服务时执行的命令</span>\n<span class="token comment">#    ExecStartPre： # 启动服务前执行的命令</span>\n<span class="token comment">#    ExecStartPost：# 启动服务后执行的命令</span>\n<span class="token comment">#    ExecStopPost： # 停止服务后执行的命令</span>\n<span class="token comment">#</span>\n<span class="token comment">#</span>\n<span class="token comment">#WantedBy字段：</span>\n<span class="token comment">#    multi-user.target: # 表示多用户命令行状态，这个设置很重要</span>\n<span class="token comment">#    graphical.target:  # 表示图形用户状体，它依赖于multi-user.target</span>\n</code></pre></div><h2 id="并发编程"><a class="header-anchor" href="#并发编程" aria-hidden="true">#</a> 并发编程</h2><p><code>Executors</code> 线程池 <code>newFixedThreadPool</code> <code>newCachedThreadPool</code> <code>newSingleThreadExecutor</code> <code>newScheduledThreadPool</code>, 最好通过<code>ThreadPoolExecutor</code>创建线程池</p><p>方法: <code>execute(Runable)</code> <code>shutdown()</code> <code>Future&lt;T&gt; submit(Callable)</code></p><p><code>Future</code> 方法<code>isDone()</code>判断任务是否执行完成, <code>get()</code>获取结果 <code>cancel()</code>取消任务</p><h2 id="函数式编程"><a class="header-anchor" href="#函数式编程" aria-hidden="true">#</a> 函数式编程</h2><p><code>Function</code>: apply andThen <code>Consumer</code>: accept 方法 <code>Predicate</code> test 方法 <code>Supplier</code>: get 方法</p><h2 id="rabbit"><a class="header-anchor" href="#rabbit" aria-hidden="true">#</a> Rabbit</h2><h3 id="注意"><a class="header-anchor" href="#注意" aria-hidden="true">#</a> 注意:</h3><ol><li>如果不指定 exchange, 默认走 amqp default exchange, ==routing-key==与==queue==名匹配一致投递</li></ol><h3 id="exchange-交换机"><a class="header-anchor" href="#exchange-交换机" aria-hidden="true">#</a> exchange 交换机</h3><ol><li>direct: ==routing-key==必须完全匹配</li><li>topic: ==routing-key==模糊匹配</li></ol><blockquote><p>#匹配多个词 *匹配一个词</p></blockquote><ol start="3"><li>fanout: ==不处==理 routing-key, exchange 与 queue 直接绑定</li></ol><h3 id="message-消息"><a class="header-anchor" href="#message-消息" aria-hidden="true">#</a> message 消息</h3><ol><li>可以携带 properties 属性</li><li>==mandotary===true, 发送端会监听到路由不到的消息, 即 returnCallback, =false 时, 路由不到的消息会被自动删除</li><li>发送端要处理==confirmCallback== ==returnCallback==, 配置里这两项必须设为 true</li><li></li></ol><h3 id="死信队列-特殊的-exchange"><a class="header-anchor" href="#死信队列-特殊的-exchange" aria-hidden="true">#</a> 死信队列(特殊的 exchange)</h3><ol><li>消息被 nack 并且 requeue=false</li><li>ttl 消息过期</li><li>队列达到最大长度</li></ol><div class="language-bash"><pre><code>私信: 就是普通的exchange--<span class="token operator">&gt;</span>queue绑定\n\n业务queue 添加额外的参数: x-dead-letter-exchange<span class="token operator">=</span>死信交换机\n\n这样业务queue上未消费的消息就路由到了私信交换机上\n</code></pre></div><h3 id="消费者"><a class="header-anchor" href="#消费者" aria-hidden="true">#</a> 消费者</h3><div class="language-java"><pre><code><span class="token annotation punctuation">@Component</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Consumer</span> <span class="token punctuation">{</span>\n\n    <span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>bindings <span class="token operator">=</span> <span class="token annotation punctuation">@QueueBinding</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token annotation punctuation">@Queue</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">&quot;test.queue&quot;</span><span class="token punctuation">,</span> durable <span class="token operator">=</span> <span class="token string">&quot;true&quot;</span><span class="token punctuation">,</span> autoDelete <span class="token operator">=</span> <span class="token string">&quot;true&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n            exchange <span class="token operator">=</span> <span class="token annotation punctuation">@Exchange</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">&quot;test.exchange&quot;</span><span class="token punctuation">,</span> durable <span class="token operator">=</span> <span class="token string">&quot;true&quot;</span><span class="token punctuation">,</span> autoDelete <span class="token operator">=</span> <span class="token string">&quot;true&quot;</span><span class="token punctuation">,</span> type <span class="token operator">=</span> <span class="token string">&quot;topic&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n            key <span class="token operator">=</span> <span class="token string">&quot;test.#&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n    <span class="token annotation punctuation">@RabbitHandler</span>\n    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">Message</span> message<span class="token punctuation">,</span> <span class="token class-name">Channel</span> channel<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> body <span class="token operator">=</span> message<span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>body<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div><h3 id="监听器"><a class="header-anchor" href="#监听器" aria-hidden="true">#</a> 监听器</h3><ol><li>simpleMessageListenerContainer</li></ol><p>为队列添加监听事件</p><ol start="2"><li><p>messageListenerAdapter 消息适配器</p><p>处理方法 可以为每个队列指定不同的处理方法</p></li><li><p>messageConvert 消息转化器 java 对象与 message 对象互转</p></li></ol><h3 id="高可用"><a class="header-anchor" href="#高可用" aria-hidden="true">#</a> 高可用</h3><ol><li><p>镜像队列 : 配置 1 个 Master, 多个 Slaver</p><div class="language-bash"><pre><code> <span class="token number">1</span>. master节点 /var/lib/rabbitmq/.erlang.cookie 拷贝到各个节点\n <span class="token number">2</span>. 启动服务 rabbitmq-server -detached\n <span class="token number">3</span>. 备用节点停止服务 rabbitmqctl stop_app\n <span class="token number">4</span>. 备用节点加入到主节点集群中 rabbitmqctl join_cluster rabbit@xxxx<span class="token punctuation">(</span>hosts名<span class="token punctuation">)</span>\n <span class="token number">5</span>. 备用节点启动 rabbitmqctl start_app\n <span class="token number">6</span>. 任意节点设置集群名 rabbitmqctl set_cluster_name xxxx\n <span class="token number">7</span>. 查看集群状态 rabbitmqctl cluster_status\n <span class="token number">8</span>. 配置镜像队列: rabbitmqctl set_policy ha-all <span class="token string">&quot;^&quot;</span> <span class="token string">&#39;{&quot;ha-mode&quot;:&quot;all}&#39;</span>\n</code></pre></div></li><li><p>haproxy: 负载均衡</p></li></ol><h3 id="插件"><a class="header-anchor" href="#插件" aria-hidden="true">#</a> 插件</h3><ol><li>延时插件<code>rabbitmq_delayed_message_exchange</code><div class="language-bash"><pre><code> <span class="token number">1</span>. /usr/lib/rabbitmq/lib/rabbitmq_serverxxx/plugins\n <span class="token number">2</span>. rabbitmq-plugins <span class="token builtin class-name">enable</span> xxxx\n <span class="token number">3</span>. 声明一个x-delayed-type类型的exchange\n <span class="token number">4</span>. 发送消息时,消息headers需要指定x-delay<span class="token operator">=</span>xx毫秒\n</code></pre></div></li></ol><h2 id="spring-事务"><a class="header-anchor" href="#spring-事务" aria-hidden="true">#</a> Spring 事务</h2><p>隔离级别:</p><div class="language-"><pre><code>ISOLATION_DEFAULT\t使用后端数据库默认的隔离级别\nISOLATION_READ_UNCOMMITTED\t允许读取尚未提交的更改。可能导致脏读、幻读或不可重复读\nISOLATION_READ_COMMITTED\t允许从已经提交的并发事务读取。可防止脏读，但幻读和不可重复读仍可能会发生\nISOLATION_REPEATABLE_READ\t对相同字段的多次读取的结果是一致的，除非数据被当前事务本身改变。可防止脏读和不可重复读，但幻读仍可能发生\nISOLATION_SERIALIZABLE\t完全服从ACID的隔离级别，确保不发生脏读、不可重复读和幻读。这在所有隔离级别中也是最慢的，因为它通常是通过完全锁定当前事务所涉及的数据表来完成的, 可以加共享锁(不排他), 一个事务不释放,其它事务只能读数据\n</code></pre></div><p>传播机制:</p><div class="language-"><pre><code>PROPAGATION_MANDATORY\t表示该方法必须运行在一个事务中。如果当前没有事务正在发生，将抛出一个异常\nPROPAGATION_NESTED\t表示如果当前正有一个事务在进行中，则该方法应当运行在一个嵌套式事务中。被嵌套的事务可以独立于封装事务进行提交或回滚。如果封装事务不存在，行为就像PROPAGATION_REQUIRES一样。\nPROPAGATION_NEVER\t表示当前的方法不应该在一个事务中运行。如果一个事务正在进行，则会抛出一个异常。\nPROPAGATION_NOT_SUPPORTED\t表示该方法不应该在一个事务中运行。如果一个现有事务正在进行中，它将在该方法的运行期间被挂起。\nPROPAGATION_SUPPORTS\t表示当前方法不需要事务性上下文，但是如果有一个事务已经在运行的话，它也可以在这个事务里运行。\nPROPAGATION_REQUIRES_NEW\t表示当前方法必须在它自己的事务里运行。一个新的事务将被启动，而且如果有一个现有事务在运行的话，则将在这个方法运行期间被挂起。\nPROPAGATION_REQUIRES\t表示当前方法必须在一个事务中运行。如果一个现有事务正在进行中，该方法将在那个事务中运行，否则就要开始一个新事务。\n</code></pre></div><h2 id="springmvc-异步处理"><a class="header-anchor" href="#springmvc-异步处理" aria-hidden="true">#</a> SpringMvc 异步处理</h2><p>Callable 多线程模式: 主线程不会被长时间阻塞</p><div class="language-java"><pre><code><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/demo&quot;</span><span class="token punctuation">)</span>\n    <span class="token keyword">public</span> <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>\n\n        <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> callable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token annotation punctuation">@Override</span>\n            <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>\n                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token keyword">return</span> <span class="token string">&quot;success&quot;</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span><span class="token punctuation">;</span>\n        <span class="token keyword">return</span> callable<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n</code></pre></div><p>DeferredResult: 接受请求—&gt;处理任务| |处理完毕–&gt;响应结果</p><h2 id="dockerfile"><a class="header-anchor" href="#dockerfile" aria-hidden="true">#</a> Dockerfile</h2><div class="language-docker"><pre><code><span class="token instruction"><span class="token keyword">from</span>  必须是第一行</span>\n<span class="token instruction"><span class="token keyword">maintainer</span> 作者信息</span>\n<span class="token instruction"><span class="token keyword">add</span> copy 拷贝文件, add功能更多, 你猜都有什么功能?</span>\n<span class="token instruction"><span class="token keyword">run</span>  构建时的命令</span>\n<span class="token instruction"><span class="token keyword">expose</span>  暴露端口,只是建议,    实际使用时还需要手动-p  指定端口映射</span>\n<span class="token instruction"><span class="token keyword">workdir</span> 指定工作目录 容器启动时执行的命令会在该目录下执行</span>\n<span class="token instruction"><span class="token keyword">cmd</span>  运行时命令,  会被使用时容器的命令覆盖</span>\n<span class="token instruction"><span class="token keyword">entrypoint</span>  不会被容器运行时命令覆盖</span>\n</code></pre></div><blockquote><p>ADD COPY ENV EXPOSE FROM LABEL STOPSIGNAL USER VOLUME WORKDIR</p></blockquote><ol><li>构建 docker 镜像</li></ol><div class="language-bash"><pre><code>docker build -t tag名称 <span class="token builtin class-name">.</span>\n<span class="token builtin class-name">.</span> 指定Dockerfile所在路径\n</code></pre></div><ol start="2"><li>登录到 hub</li></ol><div class="language-bash"><pre><code>docker login\n</code></pre></div><ol start="3"><li>推送</li></ol><div class="language-bash"><pre><code>docker push <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span> NAME<span class="token punctuation">[</span>:TAG<span class="token punctuation">]</span>\n</code></pre></div><h2 id="gradle"><a class="header-anchor" href="#gradle" aria-hidden="true">#</a> Gradle</h2><p>gradle 任务: 往 nexus 发布 jar</p><div class="language-groovy"><pre><code><span class="token comment">//Maven仓库的URL</span>\n<span class="token keyword">def</span> MAVEN_REPO_RELEASE_URL<span class="token operator">=</span> <span class="token string">&#39;http://xxxx/nexus/content/repositories/releases/&#39;</span>\n<span class="token keyword">def</span> MAVEN_REPO_SNAPSHOT_URL<span class="token operator">=</span> <span class="token string">&#39;http://xxxxx/nexus/content/repositories/snapshots/&#39;</span>\n<span class="token comment">//登录nexus 的用户名</span>\n<span class="token keyword">def</span> NEXUS_USERNAME<span class="token operator">=</span><span class="token string">&#39;admin&#39;</span>\n<span class="token comment">//登录nexus 的密码</span>\n<span class="token keyword">def</span> NEXUS_PASSWORD<span class="token operator">=</span><span class="token string">&#39;admin&#39;</span>\n<span class="token keyword">def</span> ARTIFACT_ID <span class="token operator">=</span> <span class="token string">&#39;demo&#39;</span>\n<span class="token comment">// type</span>\n<span class="token keyword">def</span> TYPE <span class="token operator">=</span> <span class="token string">&#39;jar&#39;</span>\n<span class="token comment">//description</span>\n<span class="token keyword">def</span> DESCRIPTION <span class="token operator">=</span> <span class="token string">&#39;这里是描述&#39;</span>\n\nuploadArchives <span class="token punctuation">{</span>\n    configuration <span class="token operator">=</span> configurations<span class="token punctuation">.</span>archives\n    repositories <span class="token punctuation">{</span>\n        mavenDeployer <span class="token punctuation">{</span>\n            <span class="token function">snapshotRepository</span><span class="token punctuation">(</span>url<span class="token punctuation">:</span> MAVEN_REPO_SNAPSHOT_URL<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                <span class="token function">authentication</span><span class="token punctuation">(</span>userName<span class="token punctuation">:</span> NEXUS_USERNAME<span class="token punctuation">,</span> password<span class="token punctuation">:</span> NEXUS_PASSWORD<span class="token punctuation">)</span>\n            <span class="token punctuation">}</span>\n            <span class="token function">repository</span><span class="token punctuation">(</span>url<span class="token punctuation">:</span> MAVEN_REPO_RELEASE_URL<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                <span class="token function">authentication</span><span class="token punctuation">(</span>userName<span class="token punctuation">:</span> NEXUS_USERNAME<span class="token punctuation">,</span> password<span class="token punctuation">:</span> NEXUS_PASSWORD<span class="token punctuation">)</span>\n            <span class="token punctuation">}</span>\n            <span class="token function">repository</span><span class="token punctuation">(</span>url<span class="token punctuation">:</span> <span class="token function">uri</span><span class="token punctuation">(</span><span class="token string">&#39;C:\\\\Users\\\\dd\\\\.m2\\\\repository&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//定义本地maven仓库的地址</span>\n            <span class="token function">repository</span><span class="token punctuation">(</span>url<span class="token punctuation">:</span> <span class="token function">uri</span><span class="token punctuation">(</span><span class="token string">&#39;C:\\\\Users\\\\dd\\\\.gradle\\\\caches\\\\modules-2\\\\files-2.1&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//定义本地Gradle仓库的地址</span>\n            pom<span class="token punctuation">.</span>project <span class="token punctuation">{</span>\n                version version\n                artifactId ARTIFACT_ID\n                groupId group\n                packaging TYPE\n                description DESCRIPTION\n                licenses <span class="token punctuation">{</span>\n                    license <span class="token punctuation">{</span>\n                        name <span class="token string">&#39;The Apache Software License, Version 2.0&#39;</span>\n                        url <span class="token string">&#39;http://www.apache.org/licenses/LICENSE-2.0.txt&#39;</span>\n                        distribution <span class="token string">&#39;xxxxxx&#39;</span>\n                    <span class="token punctuation">}</span>\n                <span class="token punctuation">}</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div><h2 id="jira配置"><a class="header-anchor" href="#jira配置" aria-hidden="true">#</a> jira配置</h2><p><code>setenv.sh</code></p><div class="language-bash"><pre><code>JVM_SUPPORT_RECOMMENDED_ARGS:<span class="token operator">=</span><span class="token string">&quot;-Duser.timezone=Asia/Shanghai&quot;</span>\n\n<span class="token builtin class-name">export</span> <span class="token assign-left variable">CATALINA_OPTS</span><span class="token operator">=</span><span class="token string">&quot;-javaagent:/var/atlassian/application-data/jira/agent.jar <span class="token variable">${CATALINA_OPTS}</span>&quot;</span>\n</code></pre></div><p><code>confluence setenv.sh</code></p><div class="language-bash"><pre><code><span class="token builtin class-name">export</span> <span class="token assign-left variable">CATALINA_OPTS</span><span class="token operator">=</span><span class="token string">&quot;-javaagent:/var/atlassian/application-data/confluence/agent.jar <span class="token variable">${CATALINA_OPTS}</span>&quot;</span>\n</code></pre></div><p><code>bitbucket _start-webapp.sh</code></p><div class="language-bash"><pre><code><span class="token assign-left variable">JAVA_OPTS</span><span class="token operator">=</span><span class="token string">&quot;-javaagent:/var/atlassian/application-data/bitbucket/agent.jar -classpath <span class="token variable">$INST_DIR</span>/app <span class="token variable">$JAVA_OPTS</span> <span class="token variable">$BITBUCKET_ARGS</span> <span class="token variable">$JMX_OPTS</span> <span class="token variable">$JVM_REQUIRED_ARGS</span> <span class="token variable">$JVM_SUPPORT_RECOMMENDED_ARGS</span>&quot;</span>\n</code></pre></div>',61);t.render=function(a,e,t,o,c,l){return n(),s("div",null,[p])};export default t;export{e as __pageData};
